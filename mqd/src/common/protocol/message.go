/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package protocol

import (
	"common/utils"
	"errors"
)

const MsgIdBytesSize = 8
const MsgPayloadFlagBytesSize = 1
const MsgPayloadLengthBytesSize = 3
const MsgPayloadNotNilFlag      = 0x00
const MsgPayloadNilFlag         = 0x01
const MsgPayloadIsBytesFlag     = 0x02
const MsgPayloadIsObjectFlag    = 0x04

/*
 * Message object, message sent to or received from the MQ server must be an instance of the interface.
 * The implementation of this interface is not thread safe
 *
 * Create a message using the function NewBytesMessageWithoutId, NewBytesMessage and NewEmptyBytesMessage are not recommended
 */
type IMessage interface {

	/*
	 * Get the message ID.
	 * This function can be called only on the message received by the consumer.
	 * When message sent by the producer, the message ID will be returned by Produce function, it is generated by the server side.
	 *
	 * return :
	 * message ID
	 *
	 */
	MsgId() int64

	/*
	 * Get the message body, the message body type is determined by the message type
	 *
	 * return :
	 * message body
	 *
	 */
	Payload() interface{}

	/*
	 * Clone a new message with the same message body with the new message ID
	 *
	 * parameters :
	 * newMsgId : new message ID
	 *
	 * return :
	 * a new message
	 *
	 */
	CloneWithNewMsgId(newMsgId int64) IMessage

	/*
	 * Convert a message to a byte array
	 */
	toBytes() ([]byte, error)
}

var (
	MsgIsNullError = errors.New("message can not be nil")
	ConvertBytesToMsgError = errors.New("convert bytes to message error")
	UnsupportedMsgTypeError = errors.New("unsupported message type error")
)

func MessageToBytes(message IMessage) ([]byte, error) {
	if message == nil {
		return nil, MsgIsNullError
	}

	return message.toBytes()
}

func BytesToMessage(bytes []byte) (IMessage, error) {
	if bytes == nil || len(bytes) == 0 {
		return nil, MsgIsNullError
	}

	msgBytesPackage := utils.NewIoBuffer(bytes)
	msgId := msgBytesPackage.ReadInt64()
	msgFlagByte, err := msgBytesPackage.ReadByte()
	if err != nil {
		return nil, ConvertBytesToMsgError
	}

	isPayloadNil := (msgFlagByte & MsgPayloadNilFlag) == MsgPayloadNilFlag
	isBytesMsg   := (msgFlagByte & MsgPayloadIsBytesFlag) == MsgPayloadIsBytesFlag

	if isBytesMsg {
		if isPayloadNil {
			return &BytesMessage{msgId: msgId, payload: nil}, nil
		} else {
			msgPayloadLength := msgBytesPackage.ReadUint24()
			if msgPayloadLength > 0 {
				msgPayload := msgBytesPackage.Next(int(msgPayloadLength) & 0xFFFFFF)
				return &BytesMessage{msgId: msgId, payload: msgPayload}, nil
			} else {
				msgPayload := make([]byte, 0)
				return &BytesMessage{msgId: msgId, payload: msgPayload}, nil
			}
		}
	} else {
		return nil, UnsupportedMsgTypeError
	}
}

type BytesMessage struct {

	msgId int64
	payload []byte

}

func NewBytesMessage(payload []byte, seqGen *utils.SequenceGenerator) (*BytesMessage, error) {
	if seqGen == nil {
		return nil, errors.New("SequenceGenerator can not be nil")
	}

	msgId, err := seqGen.GetSequence()
	if err != nil {
		return nil, err
	}

	return &BytesMessage{msgId: msgId, payload: payload}, nil
}

/*
 * Create a message object whose message body type is a byte array
 *
 * parameters :
 * payload : a byte array message body
 *
 * return :
 * a new message pointer
 *
 */
func NewBytesMessageWithoutId(payload []byte) *BytesMessage {
	return &BytesMessage{msgId: -1, payload: payload}
}

func NewEmptyBytesMessage(seqGen *utils.SequenceGenerator) (*BytesMessage, error) {
	emptyPayload := make([]byte, 0)
	return NewBytesMessage(emptyPayload, seqGen)
}

func (msg *BytesMessage) MsgId() int64 {
	return msg.msgId
}

func (msg *BytesMessage) Payload() interface{} {
	return msg.payload
}

func (msg *BytesMessage) CloneWithNewMsgId(newMsgId int64) IMessage {
	return &BytesMessage{msgId: newMsgId, payload: msg.payload}
}

func (msg *BytesMessage) toBytes() ([]byte, error) {
	msgPayloadLength := len(msg.payload)

	if msg.payload == nil {
		msgBytesPackage := utils.NewIoBuffer(make([]byte, 0, MsgIdBytesSize + MsgPayloadFlagBytesSize))
		msgBytesPackage.WriteInt64(msg.msgId)
		msgBytesPackage.WriteByte(MsgPayloadNilFlag | MsgPayloadIsBytesFlag)
		return msgBytesPackage.Bytes(), nil
	} else {
		msgBytesPackage := utils.NewIoBuffer(make([]byte, 0, MsgIdBytesSize + MsgPayloadFlagBytesSize + MsgPayloadLengthBytesSize + msgPayloadLength))
		msgBytesPackage.WriteInt64(msg.msgId)
		msgBytesPackage.WriteByte(MsgPayloadNotNilFlag | MsgPayloadIsBytesFlag)
		msgBytesPackage.WriteUint24(uint32(msgPayloadLength))

		if msgPayloadLength > 0 {
			msgBytesPackage.Write(msg.payload)
		}

		return msgBytesPackage.Bytes(), nil
	}
}

